function [it,population,runTime]=myGA(f,V,M,lb,ub)
% myGA(f,V,M,lb,ub)
% f : function to minimize
% V : Dimension of the search space.
% sM : Number of objectives.
% lb = lower bound vector.
% ub = upper bound vector.

%% Some settings
verbose = 0;
interpolationRecomb = 1; %choose genetic operators: either using interpolation (works in 2 stages, first 
variableParams = 0; % for interpolation, set to 1 to enable two stages

if interpolationRecomb == 0  % SBX -> fastest with variable params!
     % % If using SBX for genetics, set interval to 0 so the genetic
     % operator function knows.
    intervalScalar_start = 0; intervalScalar_end = 0;
    P_start = 1 ; 
    sd_mut_start=0.1; 
    sd_mut_rec_start= 0.01; 
    N_start=24;
    NP_start=12; 
    NC_start=24;
    
    P_end = 0.2;
    sd_mut_end=0.1; 
    sd_mut_rec_end= 0.01; 
    N_end=32;
    NP_end=4; 
    NC_end=16;
else
    % using Interpolation for genetics      ->   fastest with fixed parameters
    sd_mut_rec_start = 0; sd_mut_rec_end = 0;
    P_start = 1;	% Recomination probability
    sd_mut_start = 0.1; %standard deviation for mutation
    N_start = 24;         % Population size
    NP_start = 12;       % Size of the mating pool
    NC_start = 24;       % Number of children generated by generation
    intervalScalar_start = 1.4;

    %once you reach the pareto curve (all individuals are rank 1), switch to
    %larger population to get more points, and lower mutation as we only need
    %to tweak a little
    P_end = 1;	% Recomination probability
    sd_mut_end = 0.1; %standard deviation for mutation
    N_end = 24;         % Population size
    NP_end = 12;       % Size of the mating pool
    NC_end = 24;       % Number of children generated by generation
    intervalScalar_end = 1.4;
end
N = N_start;

%% GENETIC ALGORITHM
% Generation of the intial population
population=initPopulation(N,V,M);
population=evaluatePopulation(population,f,V,M,lb,ub);
population=sortPopulation(population,V,M);
% disp('initialPopulation')
% disp(population)

% Main loop
startTime = cputime;

it=1;
stopFlag = 0;
convergedFlag = 0;

while stopFlag==0
    % for interpolation recombination, you can specify values for the 2
    % stages (convergence to Pareto curve, then spreading and more points)
    if variableParams == 1 && convergedFlag == 1
%         disp('reached PARETO')
        P = P_end;
        sd_mut = sd_mut_end;
        sd_mut_rec = sd_mut_rec_end;
        N = N_end;
        NP = NP_end;
        NC = NC_end;
        intervalScalar = intervalScalar_end;
    else
        P = P_start;
        sd_mut = sd_mut_start;
        sd_mut_rec = sd_mut_rec_start;
        N = N_start;
        NP = NP_start;
        NC = NC_start;
        intervalScalar = intervalScalar_start;
    end
    
    % use this to enable/disable variable P and sd_mut.
    % Setting to crowdingDistanceFlag uses first variable, and when everything reached rank 1 fixed
%     if convergedFlag == 0
%         sd_mut = sd_mut_start/it + sd_mut_end;
%         P = P_start/it + P_end;
%     else
%         P = P_end;
%         sd_mut = sd_mut_end;
%     end
    parents= selectionTournament(population,NP,V,M,convergedFlag);
    offspring= geneticOperators(parents,NC,P,intervalScalar,sd_mut,sd_mut_rec,V,M,f,lb,ub);
    population = [ population ; offspring ];
    
    [~,uniqueIndividuals,~] = unique(population(:,1:V),'rows','stable');
    population = population(uniqueIndividuals,:);
    
    if convergedFlag == 0
        population = sortPopulation(population,V,M);
        population = cropPopulation(population,N);
    else
        population = sortPopulationCrowding(population,V,M,N);
    end
    
    % Visualization
    if verbose && mod(it,10)==0
        pop = [unnormalizePopulation(population(:,1:V),lb,ub) , population(:,V+1:end)]
        illustratePopulation(population,V,M,lb,ub,it);
        drawnow;
        pause(0.05);
    end
    
    [stopFlag, convergedFlag] = stopCriterion(it, population(:,V+M+1),population, V+M+2,M);
    it=it+1;
end
    
runTime = cputime - startTime;

end
        